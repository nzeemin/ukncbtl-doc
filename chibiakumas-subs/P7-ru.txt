https://youtu.be/fWeSxCL774U?list=PLp_QNRIYljFosVKGRrGD1dFCXrcmBhdvS
PDP11 Lesson P7 - Sound on the UKNC
Английский текст получен с помощью Whisper https://replicate.com/openai/whisper
Переведено на русский с помощью www.DeepL.com/Translator (бесплатная версия)


Здравствуйте, это Киф, и это седьмой урок из серии моих учебников по программированию на ассемблере PDP-11.

Мы снова смотрим на УКНЦ, и надо мной снова осциллограф, что должно говорить о том, что я, вероятно, делаю что-то связанное со звуком.

Итак, мы будем писать мой звуковой драйвер Chibi на УКНЦ.
Chibi sound - это очень простой звуковой драйвер, который я пишу на всех этих системах, и он позволяет мне издавать простые звуковые сигналы в моих играх похожим образом на всех системах, что сокращает время, необходимое для переноса игр, и уменьшает головную боль, когда я пытаюсь запомнить все различные системы, которые я программирую.

Что же делает Chibi sound? Он принимает один байт и обычно использует шесть битов для определения высоты тона.
Один бит используется для определения того, включен или выключен шум, и один бит - для определения уровня громкости.

В УКНЦ по сути, есть пищалка, очень похожая на Spectrum, где у нас есть один бит для создания формы волны.
Этот бит переворачивает форму волны, и, многократно изменяя его, мы можем создавать звуки высокого и низкого тона, а если мы будем изменять его произвольно, то это приведет к искажению звука.

Однако, насколько мне известно, мы не можем реально изменить громкость.
Поэтому сегодня мы не будем изменять громкость в звуковом драйвере Chibi.
Поэтому громкость всегда будет высокой.
Это и будет сегодняшним ограничением.

Сегодняшний код сильно отличается от кода Спектрума.
В спектрумовской версии, несмотря на то, что функция бипера очень похожа, спектрумовская версия издавала звук в течение короткого периода времени, а затем возвращалась к вызывающей процедуре, в то время как в УКНЦ два процессора, и только ПП, "со-процессор", "периферийный процессор", может действительно издавать звук.
Поэтому вместо того, чтобы возвращаться после короткого звукового сигнала, мы собираемся сделать постоянный звуковой сигнал на этом втором процессоре.
Это дает нам преимущество постоянного звука.

Однако недостатком является то, что если этот второй процессор постоянно издает звук, то он не может заниматься ничем другим, а это приводит к отключению основной функциональности ПП, и он перестает отвечать на большинство вызовов основного процессора.

Исключением является то, что я написал небольшую игру под названием Suck Shoot, которая представляет собой простую игру с летучей мышью.
Мой драйвер клавиатуры, который мы рассматривали в предыдущем примере из серии платформ, основан на прерываниях.
Поэтому звуковой драйвер на него не влияет.
Но на основной код, который будет обрабатывать эмуляцию консоли, я полагаю, это повлияет.

Вероятно, существует способ создания звукового драйвера, управляемого прерываниями.
Здесь я его не писал. Он не настолько продвинут, но, по крайней мере, будет работать в базовом варианте.

Итак, давайте сначала запустим пример и послушаем его в действии.
Для разнообразия, давайте посмотрим на него в действии.

Итак, здесь вы можете услышать, что у нас высокий тон, и он становится ниже по мере увеличения значения, я не показываю на экране значение, потому что консоль не работает.
Затем мы получим несколько искаженных звуков.

Теперь вы заметите, что форма волны немного нестабильна.
Поэтому она искажена, но в целом, чем плотнее форма волны, чем выше частота, тем выше высота тона;
чем больше расстояние между волнами, чем больше длина волны, тем ниже высота тона.

В любом случае, давайте перейдем к коду и посмотрим на него.
Итак, что же делает наш код?
Прежде всего, давайте посмотрим, что нам нужно сделать, чтобы пример со звуком заработал.

Теперь мы делаем следующее: мы берем звуковой драйвер Chibi, отправляем его на ПП и выполняем на ПП, но, в отличие от предыдущих примеров, мы не возвращаемся после его завершения, потому что на самом деле он не завершен.
Он будет продолжать издавать звук, ожидая новых данных для создания звука.
И так до бесконечности.

Итак, после того как наш драйвер включен, мы возвращаемся и изменяем этот байт CsndA, который является байтовым параметром, который мы передаем в формате, который обычно принимает Chibi sound.
Итак, нижние шесть битов - это высокое значение питча - высокий питч, низкое значение - низкий питч, и если установлен бит 7, то в итоге мы получаем звук шума.
Бит громкости игнорируется, но отключение звука выполняется как должно.
Таким образом, если мы пошлем нулевое значение, которое выключает звук, то он затихнет.

Теперь эта версия драйвера берет второй байт, это байт B, и если он не равен нулю, то драйвер завершает работу.
Причина этого заключается в том, что, как я уже сказал, ПП не работает должным образом, и мы пытаемся отправить символы на этот ПП, чтобы вывести их на экран.

Но на экране ничего не появляется, а все потому, что на пути стоит звуковой драйвер Chibi, который мешает работе всего остального.
Теперь, если мы установим в байт B ненулевое значение, это приведет к завершению работы Chibi sound, а затем к деинсталляции подпрограммы Chibi sound, освобождающей память на периферийном процессоре.

Поэтому, если мы запустим это снова, то получим
...
короткий звуковой сигнал, а затем эти символы будут выведены на экран, а до этого они передавались, но не отображались, поскольку на ПП все еще работал Chibi sound.
Поэтому, если нам нужен только короткий звуковой сигнал, мы можем выполнить эту программу, а затем попросить ее вернуться.

Если же нам нужен постоянный звуковой сигнал, то он должен работать на субпроцессоре, и, как я уже сказал, нам придется решать вопросы с графической функциональностью и функциональностью чтения с клавиатуры каким-то другим способом, поскольку субпроцессор будет полностью занят звуком Chibi.

Итак, давайте посмотрим, что, собственно, делает Chibi sound.
Прежде всего, у нас есть два байта в памяти главного процессора, которые мы используем для передачи Chibi sound, и, как и раньше, мы вычисляем адрес и делим его на два, а затем передаем в маппер памяти.
Именно так мы получаем доступ к памяти центрального процессоре из ПП.
Таким образом, именно на ПП выполняется этот код.

Итак. В некоторых случаях нам понадобятся случайные данные, а у нас нет источника случайных данных.
Поэтому мы используем часть картриджа ПЗУ, а именно диапазон адресов от B000 до D000 в шестнадцатеричном формате, который является достаточно случайным.
Он дает как бы случайный искаженный звук, и поэтому мы загружаем этот диапазон адресов в R2.
Мы будем последовательно использовать его в качестве источника случайных данных, когда нам понадобятся случайные данные.

Итак, что мы здесь делаем, так это перемещаем байт из 177014 в R0.
Это наш параметр из Chibi sound, который представляет собой высоту тона и то, включен или выключен шум, и что мы собираемся здесь сделать, так это проверить бит шума, и посмотреть, включен шум или нет.
Если шум выключен, то мы установим R3 в положение, когда верхний бит установлен в 1.
В противном случае мы установим его в 0.

Зачем мы это делаем? Ну, это верхний бит, который фактически управляет динамиком, и нам нужно использовать порт 177716 в восьмеричном формате на ПП, не на основном процессоре, а только на ПП, и это будет переключать волну.
Итак, нам нужно создать волну, это будет квадратная волна, вот такая, и каждый раз, когда мы пишем в этот порт, мы, по сути, переключаемся с одного направления на другое, и скорость переключения будет изменять высоту тона, и если мы изменим ее немного случайным образом, то это создаст искаженный звук.

Теперь, если мы хотим получить постоянный тон, мы всегда хотим переключиться со значением 1 в этом бите. Поэтому, если шум выключен, мы устанавливаем бит 7 в 1.
Вот что делает перемещение восьмеричного 200 в R3.
В противном случае нам нужно случайное значение, и мы собираемся получить его из R2.
Итак, мы загружаем в R1 значение 200, возможно, очищаем бит в зависимости от случайных данных в R2, а затем устанавливаем бит из R3, и, таким образом, R1 будет содержать либо верхний бит 1, либо 0, в зависимости от того, установлен ли шум, и мы делаем XOR-ирование с портом 177716, который переключает нашу форму волны, которая делает XOR-ы, но значение в R1, чтобы сказать, что в этом верхнем бите должна быть постоянная 1, если мы хотим постоянный тон, или он должен чередоваться, если нам нужен случайный тон.

Таким образом, мы переключаем форму волны и работаем с шумом, но нам также необходимо обработать высоту тона.
Способ обработки тона заключается в том, что мы просто ждем определенный период времени, прежде чем снова перевернуть этот бит, и у нас это есть в R0.
Мы, по сути, загрузили R0 из переданного нам байта параметров, очистили весь диапазон от 0 до 63, используя вот этот бит очистки, и просто сдвинули его влево на три бита, чтобы получить правильный диапазон для нужной нам высоты тона.

Теперь мы просто ждем здесь, ничего не делая, ничего не меняя в звуковой аппаратуре, а затем мы собираемся сделать цикл и снова перевернуть бит.
Это создаст нашу форму волны, но сначала мы выполним еще несколько действий.

Первое, что мы сделаем, это проверим второй байт - байт CsndB, который используется для завершения команды.
Поэтому мы проверим, установлен ли этот байт, и если установлен, то мы завершим работу Chibi Sound.
Мы установим флаг завершения, который используется нашей вызывающей программой для освобождения памяти, и вернемся обратно.
Если же команда завершения не установлена, то единственное, что нам остается сделать, это убедиться, что источник случайных данных в R2 не находится в конце диапазона ПЗУ, что является хорошим тоном.

Если мы поднимемся слишком высоко, то окажемся в адресах регистров устройств.
И если мы начнем читать из них, то может произойти все, что угодно.
Мы этого не хотим.
Это может привести к сбоям, а в других диапазонах появятся нули, что не позволит создать очень хорошие образцы шума.
Поэтому, как я уже сказал, мы ограничиваем R2 этим фиксированным диапазоном, но, по сути, как только мы дошли до этой точки, мы сразу же прыгаем обратно на начало и повторяем всю процедуру проверки байта Chibi Sound, проверяя, равен ли он нулю.
Если он равен нулю, то мы ничего не делаем.
В противном случае мы снова создаем звук.
А это уже создание тона.

Вот и все.
Вот как мы можем создавать звук в этой системе.
Все довольно просто, так что если вам понравилось то, что вы видели, пожалуйста, поставьте лайк и подпишитесь, потому что если вам нравится видео, YouTube его рекомендует больше, для большего количества людей, и если вы подписываетесь, я получаю удовольствие, и я сделаю больше видео.
Так что это полезно для всех.

В любом случае, как я обычно говорю, заходите на сайт, скачивайте исходный код и скрипт сборки для сегодняшнего примера, и вы сможете опробовать его и, возможно, немного развлечься и использовать его так, как вам будет удобно.
В любом случае, я надеюсь, что вам понравилось то, что вы сегодня увидели.
Спасибо за просмотр и до свидания.
