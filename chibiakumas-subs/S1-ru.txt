Английский текст получен с помощью Whisper https://replicate.com/openai/whisper
Переведено на русский с помощью www.DeepL.com/Translator (бесплатная версия)


Здравствуйте, это Киф, и это первый урок из простой серии моих уроков по программированию на ассемблере PDP-11.

Сегодня мы рассмотрим простой пример и пройдемся практически по всему исходному коду, потому что во многих предыдущих примерах, которые я делал в последнее время на PDP-11 УКНЦ, мы не рассматривали весь код, и я говорил, что вернусь к этому примеру, хоть я уже и рассматривал его раньше.

Сегодня мы рассмотрим плюс-минус весь код и обсудим каждую из секций, которые потребовались для создания сегодняшнего примера.
Сегодняшний пример - это смайлик, перемещающийся по экрану УКНЦ, вы видите, что у нас есть маленький смайлик.
Мы можем перемещать его по экрану, но он не может выйти за его пределы. Итак, мы проверяем диапазон, читаем клавиатуру и мы настроили экран.

В сегодняшнем примере для чтения клавиатуры используется периферийный процессор (ПП), но на самом деле мы перераспределили видеопамять на центральный процессор (ЦП), чтобы конечный код выполнялся с основного процессора.
Проблема заключается в том, что это означает необходимость нескольких этапов настройки:
мы должны перестроить память экрана и настроить чтение клавиатуры в обработчике прерываний, и поэтому сегодня мы посмотрим, как все это работает.

Если вы хотите узнать, как создавать растровые изображения, то смайлик был нарисован в AkuSprite editor, моем бесплатном редакторе спрайтов, и если мы работаем с PDP-11 УКНЦ, то мы сохраняем с вариантом двухбитовой плоскости сегодня вот эту вот версию, которую мы используем, потому что графика фактически на конечном экране четырехцветная:
как я уже говорил, на основной процессор замаплены только две битовые плоскости.
Третья всегда замаплена на ПП, поэтому сегодня мы используем четырехцветную графику,
и у нас есть простая проверка диапазона, чтобы убедиться, что наш смайлик не может выйти за пределы экрана.

Окей. Что ж, давайте перейдем к исходному коду.
Первое, что мы сделаем, это обсудим основы кода, который фактически выполняет чтение с клавиатуры и перемещение смайлика, и причина этого заключается в следующем.
Предполагаю, что вас не очень волнует, как работают фоновые вещи, связанные с подготовкой,
что будет проще для вас, но позже мы перейдем к деталям этих довольно сложных настроек.
Итак, давайте перейдем к коду и пройдемся по нему.

Итак, вот наша программа.
Наша программа начинается с начала памяти PDP-11.
Здесь находится наша стартовая процедура.
И первое, что мы делаем, это инициализируем экранный дисплей с помощью этой процедуры init.
Это установка экрана с разрешением 320 на 240 из четырех цветов в памяти ЦП.
На ПП имеется одна оставшаяся битовая плоскость.
Затем мы устанавливаем здесь драйвер клавиатуры, который считывает данные с клавиатуры.
Это обработчик прерываний, который будет устанавливать 16-разрядное значение при любом нажатии клавиши.
Во время этого основного цикла R1 и R2 - это положение X и Y нашего смайлика.

У нас есть процедура ShowP, которая будет показывать игроку смайлик на экране.
Эта процедура работает по XOR, и это означает, что если мы дважды нарисуем спрайт в одной и той же позиции, то второй раз она инвертирует его и фактически удалит, если он будет нарисован в одной и той же позиции дважды.
Таким образом, вызов ShowP нарисует игрока.
Затем у нас есть задержка, и мы снова вызываем ShowP в той же позиции, что приведет к его удалению.

Затем мы считываем значение с клавиатуры.
Сегодня я использую ту клавиатурную процедуру, которую мы обсуждали в прошлом выпуске цикла.
Процедура состоит из двух частей.
Первая - это считывание исходных данных, а вторая - использование эмулятора джойстика - декодирование нажатий клавиш и преобразование их в последовательность "вверх", "вниз", "влево", "вправо", "огонь 1", "огонь 2", "огонь 3" и "пауза".
Затем мы можем протестировать эти биты для наших "вверх", "вниз", "влево" и "вправо", и мы делаем это с помощью команды BIT,
которая по сути является командой AND, не изменяющей регистр.

Это позволит установить флаги в соответствии с битами.
Так, здесь мы проверяем бит 0. Здесь 1 проверяет бит 0,
И если "вверх" не нажата, другими словами, если этот бит равен 1, то мы переходим к следующему разделу.
Мы переходим сюда.
Если же "вверх" нажата, то мы проверим координаты X и Y.
В данном случае нам нужно проверить координату Y, и если мы пытаемся подняться вверх по экрану, то нам нужно проверить, не находимся ли мы уже в позиции 0, и если находимся, то пропускаем, поскольку мы уже в верхней части экрана, а если нет, то добавляем 10 в восьмеричной системе счисления, что, конечно, равно 8 в десятичной.
Таким образом, мы перемещаемся на один блок вверх по экрану.

Мы перемещаемся блоками по 8 пикселей вверх и вниз, чтобы соответствовать скорости движения влево и вправо, поскольку мы перемещаемся в байтах битовой плоскости.
Таким образом, влево и вправо эффективно перемещаются по 8 пикселей.
Итак, это вверх, затем мы делаем то же самое вниз.
Мы проверяем бит 1, который имеет значение 2, поэтому мы делаем бит 2, который фактически является AND из 2, и снова мы пропустим, если "вниз" не нажата, но если она нажата, мы проверяем нижнюю часть экрана здесь, поэтому мы проверяем наш экран высотой 240 строк здесь, и мы просто смотрим, находимся ли мы уже в нижней части экрана, и если нет, то мы двигаемся вниз по экрану.
Затем мы проделываем то же самое для левой и правой сторон экрана, на этот раз используя регистр R1, который является нашей позицией X, а не R2, который является нашей позицией Y, и это эффективно перемещает нашего игрока по экрану, проверяя диапазон.
И у нас здесь просто перезапуск бесконечного цикла, который просто показывает новое положение игрока.
Здесь у нас есть некоторая процедура для паузы, которая просто уменьшает R0, пока не достигнет 0 - очень просто.

Подпрограмма ShowP здесь - это подпрограмма, которая фактически рисует наш спрайт на экране.
Окей, как мы это делаем? Мы вычисляем место назначения в видеопаяти в десятичной системе.
Наша формула: взять 32768, что является базой видеопамяти экрана плюс 80, умножить на позицию Y.
Каждая строка имеет ширину 40 блоков, 848 пиксельных блоков, но каждый из этих блоков занимает 2 байта, так что это умножить на 80,
а затем наша позиция X умножается на 2, потому что для каждой позиции X есть 2 блока для двухбитовых плоскостей.
Таким образом, это наш расчет в восьмеричной системе счисления.
Вот так, и вы можете видеть, как это представлено здесь.
Здесь мы получаем позицию Y, умножаем на восьмеричное число 120 и получаем это значение.
Это 100000, я полагаю, добавленных к нему в восьмеричном исчислении.
Это и есть база в видеопамяти.
Это начало нашей экранной памяти.
Затем мы фактически удваиваем позицию X, сдвигая ее влево на один бит, и добавляем это значение.
Таким образом, R1 теперь содержит в место назначения смайла для в видеопамяти для той позиции, в которой мы хотим его показать. Окей.

Теперь мы загружаем адрес нашего спрайта в R4 и загружаем высоту нашего спрайта в R5.
Эта процедура была основана на той, которая была разработана для работы со спрайтами большего размера, и я сохранил эту функциональность.
Поэтому у нас есть цикл, несмотря на то, что наш спрайт имеет ширину всего один байт.
Вот почему он делает эту ненужную вещь.
Далее мы просто сохраняем адрес назначения этой строки в R3.
Мы перемещаем слово из R4, источника, и делаем XOR с экраном в R3.
Таким образом, мы перемещаем двухбитовые плоскости для одного байтового блока, одного 8-пиксельного блока, XOR-ируем его с экраном, инвертируем экран с этим значением, что означает, как я уже сказал, что если мы нарисуем его дважды, то во второй раз он исчезнет.

Так мы повторяем для любого из горизонтальных блоков, но на самом деле, хотя, я говорил вам, в этом примере это не нужно.
Как я уже сказал, если бы вы использовали более крупный спрайт, вам бы понадобилось здесь более широкое значение, большее значение.
Затем мы перемещаемся вниз на одну строку, добавляя 18 десятичное здесь, перемещаясь вниз на одну строку, и затем повторяем.
Вот так мы рисуем все строки нашего смайлика.

Теперь, у нас есть тестовое значение клавиатуры.
Это значение, которое было считано из обработчика прерывания клавиатуры.
Обработчик прерывания автоматически установит это значение, и это второй байт, который мы хотим считать для эмуляции джойстика.
Если бы нам нужны были необработанные данные, что несколько сложнее, мы бы использовали первый байт.

Вот наш спрайт смайлика.
Наш спрайт состоит из 8 строк, так что вы можете видеть, что здесь 8 строк и есть 2 битовые плоскости для каждой строки, каждый 8-пиксельный блок - это один байт.
Так что, по сути, первая из них - это первая битовая плоскость, и вы можете видеть, что она в основном установлена, потому что это цвет 1.
Но если мы хотим получить цвет 2 или 3, нам нужно установить вторую битовую плоскость, которая, как вы видите, используется редко.
В основном она используется для улыбки и глаз, так что вы можете видеть это.
Итак, это наш смайлик, и вы можете создать свой собственный с помощью редактора AkuSprite.
При желании, вы можете задать его прямо в виде числовых значений.
Вот в основном и все для нашей процедуры перемещения смайлика по экрану.

Это та часть, которую вы хотели бы изменить, если бы создавали собственную игру и не хотели беспокоиться о подготовке экрана или о том, как читать на клавиатуре.
Что ж, если вы хотите узнать об этом, что ж, приготовьтесь, потому что мы собираемся рассказать об этом прямо сейчас.
Итак, основа основ - это процедура отправки команды.
Что нам нужно сделать, так это передать команду на ПП и выполнить ее на ПП.
Это необходимо сделать, если мы хотим установить обработчик прерываний, определить расположение экрана и т.п.
Теперь у нас есть такая последовательность данных.

Это немного сложно, но это фиксированный формат, который является правильным форматом для инициирования команды на ПП.
Таким образом, ПП имеет свою собственную "операционную систему", и мы должны предоставить ему данные в правильном формате, который он поймет, что мы и делаем.
Теперь необходимо знать об одном моменте - это флаг завершения.
Это 16-битное значение.
Итак, что это такое. Это значение на ЦП, но ПП может получить доступ к памяти основного процессора через устройство, известное как устройство WRAP, и поэтому ПП выполняет свою маленькую работу.
Когда он завершает свою работу, он изменяет этот флаг в памяти центрального процессора, так что ЦП знает, что ПП завершил свою работу.
Это мы увидим в части этого кода.

Итак, в начале нашей процедуры мы рассмотрим это в очень простой форме, потому что это действительно слишком сложно, и это одна из тех вещей, которые, если вы не можете разобрать их самостоятельно, что я понимаю, то вы, вероятно, просто хотите оставить их в покое и использовать их как есть.
Итак, что мы здесь делаем, так это очищаем этот флаг в самом начале.
Затем мы устанавливаем тип запроса, который мы делаем, и то, что мы запрашиваем, это то, что мы просим у ПП выделить немного памяти.
Затем мы запускаем эту процедуру под названием PPUOut.
PPUOut - это команда, которая посылает последовательность данных на ПП, поскольку мы собираемся выполнять несколько задач.

Сначала нам нужно выделить память, затем передать нашу программу.
Затем нам нужно выполнить нашу программу, а затем мы хотим в данном случае освободить память.
Таким образом, мы выполняем все эти действия. Это все задачи с этим PPUOut.
Просто у них разные типы запросов, и запросы каждый раз будут меняться.
Вы видите, что здесь 30, там 20 и так далее, и некоторые параметры будут меняться соответствующим образом.

Итак, как же мы передаем команду?
Ну, здесь мы передаем параметры.
Мы загружаем адрес в R0, загружаем количество байт, 8 байт в десятичном формате, и передаем один байт из R0, который является параметрами, в порт 176676, который является каналом 2 для субпроцессора.
Мы передаем один байт, затем ждем, пока этот байт будет обработан проверкой 176674, и когда это завершится, когда данные будут считаны центральным процессором, мы передаем следующий байт, и так повторяем до тех пор, пока не закончим.

Итак, первый запрос - это запрос на выделение памяти, и когда он возвращается, доступная нам память уже выделена, и мы сохраняем ее в R5 для последующего использования.
Следующий запрос заключается в том, что мы хотим перенести нашу программу с основного процессора на ПП.
Затем мы хотим выполнить программу на ПП.
Затем мы ждем изменения флага завершения, который изменится, потому что последняя команда нашей программы, выполняемой на ПП, изменит его, и затем мы освобождаем выделенную память, и это процедура для всех примеров, когда мы выполняем программу на ПП.

Итак. Теперь, первая программа, которую мы запускаем, это подпрограмма Init, и вы можете видеть, что здесь имеется довольно большая документация по структуре видеопамяти, и мы не будем рассматривать это в деталях, это очень сложно.
Я лишь дам очень краткий обзор того, что мы здесь делаем.
Итак, у нас есть процедура Init, которая будет подготавливать память экрана, и основная причина, по которой мы это делаем, заключается в том, что обычно доступ к видеопамяти можно получить только через устройство-маппер, а это очень медленно.
Так что у нас есть кое-что попроще.
Мы перераспределяем память таким образом, чтобы она находилась в пределах адресации основного процессора.

Итак, первое, что мы здесь делаем, это вписываем адрес нашей таблицы строк.
Таблица строк определяет расположение строк на экране по одной за раз на ПП.
Она определяется адресом памяти 272 в восьмеричном исчислении, а мы фактически определяем таблицу строк по адресу памяти 4000 в восьмеричном исчислении.
Поэтому мы записываем этот адрес памяти в 272, и это определяет, что будет использоваться наша собственная таблица строк.
Затем мы загружаем в целевую видеопамять первую строку нашей таблицы строк.
Хотя следует отметить, что первые несколько строк не видны на экране.

Итак, что мы будем делать, так это использовать некоторые специальные команды. Каждая строка таблицы строк может выполнять различные задачи: она может определять только строку как "сырые" данные, но также может изменять структуру памяти, чтобы изменить разрешение экрана, изменить цвета и тому подобное.
Таким образом, можно делать такие умные вещи, как смена палитры в разных строках экрана, что довольно сложно, но весьма умно.
Но сегодня мы этим заниматься не будем.
Сначала мы настроим экран на ширину 320 пикселей, а не 640. Затем мы установим здесь начальные цвета.

Итак, у нас есть маленькие подпрограммы, которые выполняют подобные задачи, и они очень сложны.
Поэтому мы не будем рассматривать их подробно.
Итак, в основном вы можете видеть, что здесь есть линии, которые выполняют работу по настройке параметров, так что здесь вы можете видеть, что мы задаем масштаб, а это строка для настройки цвета.
Поэтому, если вы хотите изменить палитру, вам нужно изменить эту строку.
Если нужно изменить разрешение, то нужно изменить эту строку.
Но это все строки установки допустимого формата данных в таблице строк.

Итак, сначала мы устанавливаем разрешение, затем настраиваем палитру.
Затем мы подготовливаем 32 строки, которые на самом деле невидимы, и устанавливаем здесь STABF.
Это нужно для создания строк-заполнителей, и, по сути, все, что здесь делается - это создание последовательности строк, все из которых указывают на один и тот же адрес видеопамяти, потому что на самом деле они не будут показывать никаких экранных данных.
Это просто заполнитель.
Итак, мы создаем здесь 32 (десятичное) таких адреса, а затем создаем основную часть экрана, и основная часть экрана показывает адрес памяти 40000 (восьмеричное), 30000 было для верхней части экрана.
Но, как я уже сказал, на самом деле это ничего не изменит, это просто черный бордюр в верхней части экрана.
Итак, видеопамять для реального видимого экрана начинается на 40000 (восьмеричное), хотя следует отметить, что это адрес памяти для таблицы строк.
Реальный адрес памяти, по которому эта память отображается в ЦП, отличается.

Поэтому, как я уже сказал, в наших расчетах для назначения видеопамяти будет использоваться другой адрес памяти.
И мы создаем 240 строк основной части экрана.
Наконец, мы определяем конец экрана и возвращаемся к его началу.
Теперь, после того как мы определили макет экрана, нам необходимо отправить полную команду обратно на ЦП, и мы делаем это с помощью устройства-маппер.
Это устройство, которое может записывать данные в любую память, и в данном случае мы хотим сообщить памяти главного процессора, что работа выполнена.
Теперь мы выбираем адрес памяти для записи в порт 177010, и нам нужно вычислить адрес видеопамяти для конца флага, но поскольку память главного процессора - это фактически два банка, чередующихся байтами, мы делим адрес памяти на два, чтобы получить вычисленный адрес, по которому устройство-маппер захочет изменить этот байт.
И затем мы записываем значение минус один в эти байты памяти.
И вот мы записываем это значение в 177014, и это установит флаг завершения в отрицательное значение в памяти центрального процессора, сообщая ЦП, что работа закончена, и тогда ЦП освободит память и так далее.
И вот так мы подготавливаем нашу видеопамять в начале нашей программы.
Вот эта команда, которая настраивает экран.

А как насчет команды для клавиатуры?
Что ж, мы рассмотрим и это.
Немного бегло, но подробно.
Итак, мы собираемся создать свой собственный обработчик прерываний под названием KeyHandle.
Теперь нам нужно вычислить его относительно текущего номера строки, поскольку мы не знаем адреса памяти, с которого он будет выполняться, так как он будет передан в выделенную память на ПП.
Теперь номер текущей строки можно получить с помощью символа точки здесь, так что KeyHandle минус точка вычисляет относительный адрес в коде, и мы затем передаем его в регистр PC, когда она выполняется на ПП.
Таким образом, будет вычислен правильный адрес для KeyHandler, когда эта программа будет запущена на ПП.

При этом мы устанавливаем обработчик прерывания на ПП, передавая этот адрес в память по адресу 300, который является адресом обработчика прерывания.
Это означает, что обработчик прерывания KeyHandler будет запускаться на ПП при каждом нажатии клавиши.
Затем мы устанавливаем флаг завершения и возвращаемся обратно.
На этом, собственно, программа и заканчивается, поскольку вся остальная работа будет выполнена при возникновении прерывания.
Итак, когда произойдет прерывание, на ПП автоматически выполнится KeyHandle.
Нам нужно сделать резервную копию некоторых регистров, а также адрес враппера, поскольку устройство враппера используется "операционной системой".

Но мы собираемся использовать его для хранения нажатых клавиш.
Поэтому мы получаем текущую нажатую клавишу с помощью 177702.
Это текущее нажатие клавиши, и затем мы собираемся обработать это нажатие.
Теперь формат нажатия клавиш немного странный и слегка раздражающий, но он вполне пригоден для использования, просто немного раздражает.
Итак, в основном у нас есть серия нажатий клавиш в зависимости от того, какие клавиши мы хотим прочитать, и в первую очередь мы будем читать клавиши управления курсором.
При нажатии клавиши верхний бит будет равен нулю, а остальные семь битов будут кодом клавиши.
При отпускании клавиши верхний бит будет равен единице, следующие три бита - нулю, а в нижних четырех битах мы получим частичный код клавиши.
Таким образом, мы не получим полный код клавиши.
Теперь мы собираемся проверить верхний бит; если верхний бит равен единице, то флаг "минус" будет установлен, и мы перейдем к этой процедуре KyUP.
В противном случае мы перейдем к этой процедуре для нажатия "вниз", расположенной сразу после ветви для "минус", и она будет проверять таблицу маппинга клавиш.

Это нажатия клавиш: "вверх", "вниз", "влево", "вправо", "пробел", "Ввод", "регистр" и "выход".
Это восемь нажатий клавиш, которые составят восемь битов возвращаемого байта.
Таким образом, мы имитируем некий джойстик.
Поэтому, если вы захотите изменить клавиши направления или что-то еще, вы измените коды этих клавиш.
И, надеюсь, вам не придется менять саму процедуру.

Процедура загружает байт из этой таблицы поиска и повторяет его до тех пор, пока не найдет нажатие клавиши или не закончит работу;
Если клавиша совпадает, то происходит очистка битов, соответствующих второму байту кода ключа.
Так, например, если код клавиши был 154, то клавиша "вверх" была нажата, и мы хотим очистить бит 0, для чего выполним очистку бита со значением 1. При этом предполагается, что ненажатая клавиша будет иметь значение 255, а нажатая - 0.
Таким образом, Вот что мы здесь делаем.

Таким образом, мы просто многократно просматриваем эту маску в поисках ненажатых клавиш.
Когда мы находим нажатую клавишу, мы очищаем биты, и для этого мы передаем по адресу маппера, по адресу второго байта устройства-маппера 177015, и это установит второй байт тестового значения клавиши в  памяти ЦП.
Таким образом, устанавливаются те значения эмуляции джойстика, которые мы считывали ранее.
Когда нажата клавиша "вниз", мы сравниваем со всем байтом, считанным из этой таблицы маппинга клавиш, весь байт, но когда клавиша поднята вверх, процедура отличается:

Сначала мы очищаем верхний бит параметра, который мы считываем, поскольку верхний бит обозначает что сама клавиша отпущена, а затем мы считываем байты, как и раньше, из таблицы маппинга клавиш, но поскольку только четыре бита фактически устанавливаются при отпускании клавиши, мы очищаем оставшиеся биты здесь.
Затем мы сравниваем со значением, которое было считано обработчиком прерывания, то есть со значением нажатия клавиши, и если значение совпадает, то мы устанавливаем биты, фактически устанавливая этот бит направления в 1.
Но поскольку может совпасть несколько значений, так как у нас есть только частичный код клавиши, мы продолжаем сканирование до тех пор, пока не доберемся до байта с двойным нулем в конце.
Вот что мы делаем в этом случае.
Теперь, когда совпадение найдено, мы устанавливаем биты, фактически устанавливая их в 1.
На этом все по процедуре нажатия клавиши.

Теперь, как я уже сказал, все это, к сожалению, немного усложняется из-за схемы с разделением процессоров - у нас два процессора, и это означает, что некоторые вещи немного усложняются.
Но давайте уже закончим с сегодняшним примером, и, как я всегда говорю, вы можете зайти на мой сайт, скачать исходный код, скрипты сборки и использовать мой пример так, как вам захочется.

Части кода для управления и ПП были написаны кем-то другим, я нашел их в Интернете, так что я не могу приписать себе все это, и мне очень помогли с информацией о таблицах строк, поскольку оригинал был на русском языке.
Так что я получил всю эту информацию бесплатно.
И поэтому вы также можете использовать ее, так как захотите.
Развлекайтесь и сделайте что-нибудь интересное.

В любом случае, надеюсь, вам понравилось то, что вы сегодня увидели.
Спасибо за просмотр и до свидания.
